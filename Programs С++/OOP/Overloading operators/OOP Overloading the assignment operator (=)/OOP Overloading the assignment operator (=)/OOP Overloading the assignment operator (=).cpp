// OOP Copying constructor.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
using namespace std;

class MyClass
{

public:
    int* data;

    //                                      Конструкторы

    // Конструктор создания объекта
    MyClass(int size)
    {
        this->Size = size; // Данное поле объекта содержит размер массива  
        // Выделение памяти под массив (при создании объекта)
        this->data = new int[size]; // Данное поле объекта является массива 

        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }

        // this выведет адрес в памяти данного конструктора
        cout << "Вызвался конструктор " << this << endl;
    }//;

    // Конструктор копирования
    MyClass(const MyClass& other)
    {
        cout << "Вызвался конструктор копирования " << this << endl;
        // Следующая реализация создаёт новый объект с таким кол. яч. массива, сколько их в коп. об.

        // Выполняем коп. пер. Size из переданного объекта в создаваемый объект 
        this->Size = other.Size;
        // Создание массива с размером равным размеру массива переданного элемента 
        this->data = new int[this->Size];
        // Цикл переписи значений из массива 2 об. в массив 1 об.
        for (int i = 0; i < other.Size; i++)
        {
            this->data[i] = other.data[i];
        }

    }

    //                              Перегрузка операторов

    // Перегрузка оператора присваивания
    
    // В качестве параметра данной прегрузке оператора присваивания передаётся
    // объект класса MyClass, свойства которого необходимо присвоить другому объекту
    // Данный оператор должен возвращать ссылку на текущий объект =>
    // тип данных данного оператора должен быть следующим => 
    // в конце реализации должна быть строчка return *this;
    MyClass & operator = (const MyClass& other)
    {
        cout << "Вызвался оператор = " << this << endl;

        // Прежде чем записывать значения из одного объекта в другой
        // необходимо затиреть старые значения 

        // При копировании необходимо изменить поле, отвечающее за размер массива
        this->Size = other.Size;

        // Данная проверка необязательна, так как в конструкторе класса 
        // всегда будет выделяться память под массив
        // Если бы это выделение не происходило всегда, 
        // то данная проверка защищала бы данные необходимые пк от удаления
        if (this->data != nullptr)
        {
            delete[] this->data;
        }

        this->data = new int[this->Size];

        // Цикл переписи значений из массива_2 об. в массив_1 об.
        for (int i = 0; i < other.Size; i++)
        {
            this->data[i] = other.data[i];
        }

        return *this;
    }

    // методы 
    void func(MyClass value) // это передача пар. в функцию по значению
    {
        cout << "Вывелась функция func " << endl;
    }


    // Деструктор для уничтожения объекта
    ~MyClass()
    {
        // this выведет адрес в памяти данного деструктора
        cout << "Вызвался деструктор " << this << endl;

        delete[] data;
    }//;

private:
    int Size;

};


int main()
{
    setlocale(0, "rus");

//    MyClass a(10); // Создание объекта (Он будет содержать 1м массив на 10 эл.) 
//
//    MyClass b(a); // Создание копии объекта а
//    // Если использовать констр. коп. по умолч. программа выдаст ошибку:
///**/
//    // т.к. для создания копии объекта а исп. констр. по умолч.
//    // В реализации конст. коп. по умолчанию происходит запись адреса в памяти переданного объекта (а)
//    // в объект (b)
//    // Это значит, что оба объекта будут хранить указатель на 1 и тот же массив.
//    // => при вызове деструктора будет произведена очистка одной и той-же памяти дважды
//    // что и приведёт к ошибке

    MyClass a(10);
    MyClass b(2);
    MyClass c(5);

    a = b = c;


    return 0;
}
