// Виртуальный деструктор класса 105.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>

using namespace std;

class A
{

public:
    A()
    {
        cout << "Имитация. Выделена динамическая память под объект класса А!" << endl;
    }
    
    ~A()
    {
        cout << "Имитация. Динамическая память из объекта класса А освобождена!" << endl;
    }
};

class B : public A
{

public:
    B()
    {
        cout << "Имитация. Выделена динамическая память под объект класса B!" << endl;
    }

    ~B()
    {
        cout << "Имитация. Динамическая память из объекта класса B освобождена!" << endl;
    }
};


class C
{

public:
    C()
    {
        cout << "Имитация. Выделена динамическая память под объект класса C!" << endl;
    }

    virtual ~C()
    {
        cout << "Имитация. Динамическая память из объекта класса C освобождена!" << endl;
    }
};

class D : public C
{

public:
    D()
    {
        cout << "Имитация. Выделена динамическая память под объект класса D!" << endl;
    }

    ~D() override
    {
        cout << "Имитация. Динамическая память из объекта класса D освобождена!" << endl;
    }
};
int main()
{
    setlocale(0, "rus");

    //      Здесь происходит запись ссылки на объект 
    // дочернего класса в указатель объекта родительского класса 
    //      Здесь также произойдёт утечка памяти, т.к. деструктор
    // родительского класса не был виртуальным. Поэтому в момент исп.
    // кл. слова delete компилятор посмотрит, что указатель имеет тип класса А
    // найдёт в классе А деструктор, и так как деструктор не виртуальный
    // он вызовет только его
    ////A * ptrB = new B;
    ////delete ptrB;

    //      Здесь не произойдёт утечка памяти, т.к. деструктор
    // родительского класса виртуальный. Поэтому в момент исп.
    // кл. слова delete компилятор посмотрит, что указатель имеет тип класса С
    // найдёт в классе С деструктор, и так как деструктор виртуальный
    // он сначала вызовет деструктор объекта D, а потом деструктор объекта С, тем самым грамотно очистив память
    C* ptrD = new D;
    delete ptrD;
    return 0;
}
